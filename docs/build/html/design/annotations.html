
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Element Types and Annotations &#8212; TigerShark 3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Implementation" href="../implementation/index.html" />
    <link rel="prev" title="Type Hints and JSON Schema" href="type_hints.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="element-types-and-annotations">
<span id="design-annotations"></span><h1>Element Types and Annotations<a class="headerlink" href="#element-types-and-annotations" title="Permalink to this heading">¶</a></h1>
<p>Currently, the <a class="reference internal" href="../implementation/x12.html#x12.base.Element" title="x12.base.Element"><code class="xref py py-mod docutils literal notranslate"><span class="pre">x12.base.Element</span></code></a> class defines individual, atomic elements.
Is this necessary? Or can we approach it without the added overhead of these classes?
Can we replace them with type annotations and focus on the
collections (i.e. Composites and Segments)?</p>
<p>We have the following considerations:</p>
<ul class="simple">
<li><p>Providing a complete JSON Schema definition for an Element of a Message.</p></li>
<li><p>Using the Annotation information to convert between serialized text and native Python values.</p></li>
<li><p>Updating <code class="docutils literal notranslate"><span class="pre">tools/xml_extract.py</span></code> application.</p></li>
</ul>
<section id="essential-schema-details">
<h2>Essential Schema Details<a class="headerlink" href="#essential-schema-details" title="Permalink to this heading">¶</a></h2>
<p>We have the XML source files with the definition
of the schema. These appear to be derived from the
source .SEF files, which we don’t have.</p>
<p>The schema details in the XML source files include the following:</p>
<dl class="field-list">
<dt class="field-odd">Text without further specifications<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'AN'</span></code> or <code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'ID'</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">str</span></code> type needs length information in addition to the base type.
This should become <code class="docutils literal notranslate"><span class="pre">typing.Annotated[str,</span> <span class="pre">MinLen(x),</span> <span class="pre">MaxLen(y)]</span></code>.</p>
<p>The annotation becomes JSONSchema <code class="docutils literal notranslate"><span class="pre">{&quot;type&quot;:</span> <span class="pre">&quot;string&quot;,</span> <span class="pre">&quot;minLength&quot;:</span> <span class="pre">x,</span> <span class="pre">&quot;maxLength&quot;:</span> <span class="pre">y}</span></code></p>
</dd>
<dt class="field-even">Text with a list of values<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'AN'</span></code> or <code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'ID'</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Literal[&quot;value&quot;,</span> <span class="pre">...]</span></code> type could be used for this; it has the advantage of being supported directly by <strong>mypy</strong>.
An alternative is <code class="docutils literal notranslate"><span class="pre">typing.Annotated[str,</span> <span class="pre">MinLen(2),</span> <span class="pre">MaxLen(2),</span> <span class="pre">Enumerated(&quot;value&quot;,</span> <span class="pre">&quot;value&quot;)]</span></code>;
while somewhat more internally consistent, it bypasses <strong>mypy</strong>.</p>
<p>The annotation becomes JSONSchema <code class="docutils literal notranslate"><span class="pre">{&quot;type&quot;:</span> <span class="pre">&quot;string&quot;,</span> <span class="pre">&quot;minLength&quot;:</span> <span class="pre">x,</span> <span class="pre">&quot;maxLength&quot;:</span> <span class="pre">y,</span> <span class="pre">&quot;enum&quot;:</span> <span class="pre">[values,</span> <span class="pre">...]}</span></code></p>
</dd>
<dt class="field-odd">Text with a format specification<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'DT'</span></code> or <code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'TM'</span></code>.</p>
<p>The Python <code class="docutils literal notranslate"><span class="pre">str</span></code> type needs format information in addition to the base type.
This could be <code class="docutils literal notranslate"><span class="pre">typing.Annotated[str,</span> <span class="pre">MinLen(4),</span> <span class="pre">MaxLen(4),</span> <span class="pre">Format(r'\d\d\d\d')]</span></code>.
The conversion to <code class="docutils literal notranslate"><span class="pre">datetime.date</span></code> or <code class="docutils literal notranslate"><span class="pre">datetime.time</span></code>, however, omitted when using a <code class="docutils literal notranslate"><span class="pre">str</span></code>-focused type annotation.</p>
<p>This should be <code class="docutils literal notranslate"><span class="pre">typing.Annotated[datetime.time,</span> <span class="pre">Format('%H%M')]</span></code> or <code class="docutils literal notranslate"><span class="pre">typing.Annotated[datetime.date,</span> <span class="pre">Format('%Y%m%d')]</span></code>.
In the exotic cases of permitting either 6- or 8-position dates, <code class="docutils literal notranslate"><span class="pre">typing.Annotated[datetime.date,</span> <span class="pre">Format('%Y%m%d'),</span> <span class="pre">Format('%y%m%d')]</span></code> might be workable.</p>
<p>Preserving the length information (to be consistent with other annotations)
is redundant, but possibly helpful. Consider <code class="docutils literal notranslate"><span class="pre">typing.Annotated[datetime.time,</span> <span class="pre">MinLen(4),</span> <span class="pre">MaxLen(4),</span> <span class="pre">Format('%H%M')]</span></code>.</p>
<p>The annotation becomes JSONSchema <code class="docutils literal notranslate"><span class="pre">{&quot;type&quot;:</span> <span class="pre">&quot;string&quot;,</span> <span class="pre">&quot;minLength&quot;:</span> <span class="pre">x,</span> <span class="pre">&quot;maxLength&quot;:</span> <span class="pre">y,</span> <span class="pre">&quot;format&quot;:</span> <span class="pre">&quot;\d\d\d\d&quot;,</span> <span class="pre">&quot;conversion&quot;:</span> <span class="pre">&quot;date&quot;}</span></code>.
An extension attribute, “conversion”, is required to clarify the need for a conversion when serializing or deserializing.</p>
</dd>
<dt class="field-even">“Real” numbers<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'R'</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">float</span></code> type with additional sizing information to describe the source text.
This is <code class="docutils literal notranslate"><span class="pre">typing.Annotated[float,</span> <span class="pre">MinLen(4),</span> <span class="pre">MaxLen(4)]</span></code>.</p>
<p>The annotation becomes JSONSchema <code class="docutils literal notranslate"><span class="pre">{&quot;type&quot;:</span> <span class="pre">&quot;number&quot;,</span> <span class="pre">&quot;minLength&quot;:</span> <span class="pre">x,</span> <span class="pre">&quot;maxLength&quot;:</span> <span class="pre">y,</span> <span class="pre">&quot;format&quot;:</span> <span class="pre">&quot;\d\d\d\d&quot;,</span> <span class="pre">&quot;conversion&quot;:</span> <span class="pre">&quot;date&quot;}</span></code>.</p>
</dd>
<dt class="field-odd">Numbers<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'N'</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">int</span></code> type with additional sizing information to describe the source text.
This is <code class="docutils literal notranslate"><span class="pre">typing.Annotated[int,</span> <span class="pre">MinLen(4),</span> <span class="pre">MaxLen(4)]</span></code>.</p>
<p>The annotation becomes JSONSchema <code class="docutils literal notranslate"><span class="pre">{&quot;type&quot;:</span> <span class="pre">&quot;integer&quot;,</span> <span class="pre">&quot;minLength&quot;:</span> <span class="pre">x,</span> <span class="pre">&quot;maxLength&quot;:</span> <span class="pre">y,</span> <span class="pre">&quot;format&quot;:</span> <span class="pre">&quot;\d\d\d\d&quot;,</span> <span class="pre">&quot;conversion&quot;:</span> <span class="pre">&quot;date&quot;}</span></code>.
This uses the common extension of “integer” instead of “number”.</p>
</dd>
<dt class="field-even">Decimal numbers<span class="colon">:</span></dt>
<dd class="field-even"><p>Any of the various <code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'Nx'</span></code> options.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Decimal</span></code> type with additional sizing information to describe the source text.
Note that decimal points are <em>not</em> part of the source representation, and the <cite>scaleb()</cite> method
must be used.
A type of <code class="docutils literal notranslate"><span class="pre">'data_type_code':</span> <span class="pre">'N2'</span></code>, for example, this is <code class="docutils literal notranslate"><span class="pre">typing.Annotated[decimal.Decimal,</span> <span class="pre">MinLen(4),</span> <span class="pre">MaxLen(4),</span> <span class="pre">Scale(2)]</span></code>.</p>
<p>The annotation becomes JSONSchema <code class="docutils literal notranslate"><span class="pre">{&quot;type&quot;:</span> <span class="pre">&quot;str&quot;,</span> <span class="pre">&quot;minLength&quot;:</span> <span class="pre">x,</span> <span class="pre">&quot;maxLength&quot;:</span> <span class="pre">y,</span> <span class="pre">&quot;format&quot;:</span> <span class="pre">&quot;\d\d\d\d&quot;,</span> <span class="pre">&quot;conversion&quot;:</span> <span class="pre">&quot;decimal&quot;,</span> <span class="pre">&quot;scale&quot;:</span> <span class="pre">2}</span></code>.
An extension attributes, “conversion” and “scale”, are required to clarify the need for a conversion when serializing or deserializing.</p>
</dd>
</dl>
<p>Using annotations almost eliminates the need for a separate class definition for each element.
The nuanced details of the title for an element introduces a tiny complication.
Adding <code class="docutils literal notranslate"><span class="pre">Title(&quot;Number</span> <span class="pre">of</span> <span class="pre">Included</span> <span class="pre">Functional</span> <span class="pre">Groups&quot;)</span></code> as part of the annotations provides a way
to include this information in a JSON Schema document.</p>
<p>This permits type definitions to become first-class <code class="docutils literal notranslate"><span class="pre">TypeAlias</span></code> definitions.
These can be properly re-used in segment definitions.</p>
</section>
<section id="data-validation">
<h2>Data Validation<a class="headerlink" href="#data-validation" title="Permalink to this heading">¶</a></h2>
<p>The source data can be validated by these detailed annotations.</p>
<p>There are two tiers to validation:</p>
<ul class="simple">
<li><p><strong>Structural</strong>. The <code class="docutils literal notranslate"><span class="pre">parse()</span></code> methods all gather source text and apply the overall
Message, Loop, or Segment class to build an instance.
The structural type hints of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">SomeClass</span></code>, <code class="docutils literal notranslate"><span class="pre">y:</span> <span class="pre">list[SomeClass]</span></code>,
are exploited to understand the structure of message and loop.</p></li>
<li><p><strong>Elemental</strong>. For Composites and Elements, the <code class="docutils literal notranslate"><span class="pre">build()</span></code> method is used to construct
these foundational objects. At this level,
<code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">SomeTypeAlias</span></code> becomes important for converting the text source
into a Python object.</p></li>
</ul>
<p>The Segment parsing is – of course – the most complicated because it’s a
mix of structural and elemental. Overall, the segment is structural: it’s a sequence of individual elements or composites.
However, each element has elemental validation and conversion rules.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Source Text and Python Objects</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Element</span></code> class currenly keeps both source text and converted value.</p>
<p>This is handy for tracking down a parsing problem.
It permits displaying a Segment that has an invalid element to provide debugging context.</p>
<p>Eliminating the <code class="docutils literal notranslate"><span class="pre">Element</span></code> objects <em>also</em> means tracking the parsing
state to provide ample context for invalid data.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">parse()</span></code> methods have a <code class="docutils literal notranslate"><span class="pre">match</span></code> statement for the various
type hints. Currently, there are <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">_</span> <span class="pre">if</span> <span class="pre">issubclass(field_type,</span> <span class="pre">Element):</span></code>
and <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">_</span> <span class="pre">if</span> <span class="pre">issubclass(field_type,</span> <span class="pre">Composite):</span></code> clauses that must be replaced
with <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">_AnnotatedAlias()</span> <span class="pre">as</span> <span class="pre">p:</span></code> to examine the annotations in detail.</p>
<p>It seems easiest to have a generic <code class="docutils literal notranslate"><span class="pre">convert(annotation:</span> <span class="pre">_AnnotatedAlias,</span> <span class="pre">source:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">Any</span></code>
function. However, the first parameter of an annotation is a base type,
permitting a <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">get_args(p)[0]:</span></code> statement to use type-specific
converters: <code class="docutils literal notranslate"><span class="pre">str_convert(annotation:</span> <span class="pre">_AnnotatedAlias,</span> <span class="pre">source:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></code>, etc,
for the supported <code class="docutils literal notranslate"><span class="pre">str</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">datetime.date</span></code>, <code class="docutils literal notranslate"><span class="pre">datetime.time</span></code>, <code class="docutils literal notranslate"><span class="pre">Decimal</span></code> types.</p>
</section>
<section id="additional-schema-details">
<h2>Additional Schema Details<a class="headerlink" href="#additional-schema-details" title="Permalink to this heading">¶</a></h2>
<p>It’s not perfectly clear where supplemental data like the Segment identifier string and the “position” information
should be carried. Should this be part of the docstring? Or should it be a separate attribute-like feature
of the class? Or should it be an internal class stripped down to these two features?</p>
<p>Here’s a potential segment definition with no reuse of type information.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ISA_LOOP_IEA</span><span class="p">(</span><span class="n">Segment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interchange Control Trailer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">class</span> <span class="nc">Schema</span><span class="p">:</span>
        <span class="n">segment_name</span> <span class="o">=</span> <span class="s2">&quot;IEA&quot;</span>
        <span class="n">position</span> <span class="o">=</span> <span class="mi">30</span>

    <span class="n">iea01</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">MinLen</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">Scale</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Title</span><span class="p">(</span><span class="s2">&quot;Number of Included Functional Groups&quot;</span><span class="p">)]</span>
    <span class="n">iea02</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">MinLen</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">Scale</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Title</span><span class="p">(</span><span class="s2">&quot;Interchange Control Number&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>Here’s a potential segment definition with reuse.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N0</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">Scale</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
<span class="n">I16</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">N0</span><span class="p">,</span> <span class="n">MinLen</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="n">I12</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">N0</span><span class="p">,</span> <span class="n">MinLen</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">ISA_LOOP_IEA</span><span class="p">(</span><span class="n">Segment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interchange Control Trailer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">class</span> <span class="nc">Schema</span><span class="p">:</span>
        <span class="n">segment_name</span> <span class="o">=</span> <span class="s2">&quot;IEA&quot;</span>
        <span class="n">position</span> <span class="o">=</span> <span class="mi">30</span>

    <span class="n">iea01</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">I16</span><span class="p">,</span> <span class="n">Title</span><span class="p">(</span><span class="s2">&quot;Number of Included Functional Groups&quot;</span><span class="p">)]</span>
    <span class="n">iea02</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">I12</span><span class="p">,</span> <span class="n">Title</span><span class="p">(</span><span class="s2">&quot;Interchange Control Number&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>This form (with reuse) may better preserve the source document definitions.
This may make changes somewhat simpler because definitions are not repeated.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Tiger_shark2.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">TigerShark</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../operation.html">Using TigerShark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usecase.html">Context: Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">Architecture and Design</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Design Notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="classmodel.html">Message Schema as Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="loopmodel.html">Loops as Namespace</a></li>
<li class="toctree-l2"><a class="reference internal" href="parsing.html">Parsing Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_hints.html">Type Hints</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Element Types and Annotations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../implementation/index.html">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../todo.html">The TODO List</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Design Notes</a><ul>
      <li>Previous: <a href="type_hints.html" title="previous chapter">Type Hints and JSON Schema</a></li>
      <li>Next: <a href="../implementation/index.html" title="next chapter">Implementation</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, S.Lott.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/design/annotations.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>